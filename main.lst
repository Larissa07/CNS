CCS PCM C Compiler, Version 4.038, 42871               04-ago-11 09:54

               Filename: C:\Documents and Settings\Administrador\CNS\main.lst

               ROM used: 676 words (8%)
                         Largest free fragment is 2048
               RAM used: 9 (2%) at main() level
                         13 (4%) worst case
               Stack:    3 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   28B
0003:  NOP
.................... #include <16f876a.h> 
.................... //////// Standard Header file for the PIC16F876A device //////////////// 
.................... #device PIC16F876A 
.................... #list 
....................  
.................... #use delay(clock=16000000) 
0055:  MOVLW  26
0056:  MOVWF  04
0057:  BCF    03.7
0058:  MOVF   00,W
0059:  BTFSC  03.2
005A:  GOTO   069
005B:  MOVLW  05
005C:  MOVWF  78
005D:  CLRF   77
005E:  DECFSZ 77,F
005F:  GOTO   05E
0060:  DECFSZ 78,F
0061:  GOTO   05D
0062:  MOVLW  2E
0063:  MOVWF  77
0064:  DECFSZ 77,F
0065:  GOTO   064
0066:  GOTO   067
0067:  DECFSZ 00,F
0068:  GOTO   05B
0069:  RETLW  00
.................... #include <teclado.c> 
.................... #define baixo    PIN_B4 
.................... #define direita  PIN_B5 
.................... #define esquerda PIN_B2 
.................... #define cima     PIN_B3 
....................  
.................... char teclado() 
.................... { 
....................    char tecla=0; 
*
01F2:  CLRF   23
....................    if(!input(cima))tecla=1; 
01F3:  BSF    03.5
01F4:  BSF    06.3
01F5:  BCF    03.5
01F6:  BTFSC  06.3
01F7:  GOTO   1FA
01F8:  MOVLW  01
01F9:  MOVWF  23
....................    if(!input(esquerda))tecla=2; 
01FA:  BSF    03.5
01FB:  BSF    06.2
01FC:  BCF    03.5
01FD:  BTFSC  06.2
01FE:  GOTO   201
01FF:  MOVLW  02
0200:  MOVWF  23
....................    if(!input(direita))tecla=3; 
0201:  BSF    03.5
0202:  BSF    06.5
0203:  BCF    03.5
0204:  BTFSC  06.5
0205:  GOTO   208
0206:  MOVLW  03
0207:  MOVWF  23
....................    if(!input(baixo))tecla=4; 
0208:  BSF    03.5
0209:  BSF    06.4
020A:  BCF    03.5
020B:  BTFSC  06.4
020C:  GOTO   20F
020D:  MOVLW  04
020E:  MOVWF  23
....................    return tecla; 
020F:  MOVF   23,W
0210:  MOVWF  78
.................... } 
0211:  RETLW  00
....................  
.................... #include <lcd_modificado.c> 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *                                                                     * 
....................  *             Rotina Gen칠rica de Manipula칞칚o de LCD 16x2              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
.................... // Defina os pinos que est칚o ligados fisicamente 
....................  
.................... #define  RS    PIN_C0    // Pino de sele칞칚o de modo do display 
.................... #define  EN    PIN_A5    // Pino de habilita칞칚o do display 
.................... #define  D7    PIN_A0   // Pino de dados 7 
.................... #define  D6    PIN_A1    // Pino de dados 6 
.................... #define  D5    PIN_A2    // Pino de dados 5 
.................... #define  D4    PIN_A3    // Pino de dados 4 
....................  
.................... //prot遭ipo das fun貿es 
.................... void lcd_inst4(unsigned char dado); 
.................... void lcd_inst(unsigned char dado); 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                      Rotina de Inicializa칞칚o de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
.................... void inicializa_lcd(void) 
.................... { 
....................  
....................    lcd_inst4(0b00000011); 
*
013A:  MOVLW  03
013B:  MOVWF  23
013C:  CALL   06A
....................    delay_ms(15); 
013D:  MOVLW  0F
013E:  MOVWF  26
013F:  CALL   055
....................    lcd_inst4(0b00000011); 
0140:  MOVLW  03
0141:  MOVWF  23
0142:  CALL   06A
....................    delay_ms(15); 
0143:  MOVLW  0F
0144:  MOVWF  26
0145:  CALL   055
....................    lcd_inst4(0b00000011); 
0146:  MOVLW  03
0147:  MOVWF  23
0148:  CALL   06A
....................    delay_ms(15); 
0149:  MOVLW  0F
014A:  MOVWF  26
014B:  CALL   055
....................    lcd_inst4(0b00000010); 
014C:  MOVLW  02
014D:  MOVWF  23
014E:  CALL   06A
....................    delay_ms(15); 
014F:  MOVLW  0F
0150:  MOVWF  26
0151:  CALL   055
....................  
....................    lcd_inst(0b00101000); 
0152:  MOVLW  28
0153:  MOVWF  23
0154:  CALL   0B5
....................    delay_ms(15); 
0155:  MOVLW  0F
0156:  MOVWF  26
0157:  CALL   055
....................    lcd_inst(0b00001100); 
0158:  MOVLW  0C
0159:  MOVWF  23
015A:  CALL   0B5
....................    delay_ms(15); 
015B:  MOVLW  0F
015C:  MOVWF  26
015D:  CALL   055
....................    lcd_inst(0b00000110); 
015E:  MOVLW  06
015F:  MOVWF  23
0160:  CALL   0B5
....................    delay_ms(15); 
0161:  MOVLW  0F
0162:  MOVWF  26
0163:  CALL   055
....................    lcd_inst(0b00000001); 
0164:  MOVLW  01
0165:  MOVWF  23
0166:  CALL   0B5
....................    delay_ms(100); 
0167:  MOVLW  64
0168:  MOVWF  26
0169:  CALL   055
.................... } 
016A:  BCF    0A.3
016B:  BCF    0A.4
016C:  GOTO   29B (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Comando para o LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void lcd_inst4(unsigned char dado) 
.................... { 
....................  
....................    output_low(RS);                          //Limpa o pino RS, modo comando 
*
006A:  BCF    20.0
006B:  MOVF   20,W
006C:  BSF    03.5
006D:  MOVWF  07
006E:  BCF    03.5
006F:  BCF    07.0
*
0296:  MOVLW  FF
0297:  BCF    03.5
0298:  MOVWF  20
....................    delay_us(100); 
*
0070:  MOVLW  85
0071:  MOVWF  77
0072:  DECFSZ 77,F
0073:  GOTO   072
....................  
....................    if (dado & 0b00001000) output_high(D7);         //Se o bit estiver em 1 liga a sa칤da 
0074:  BTFSS  23.3
0075:  GOTO   07B
0076:  BSF    03.5
0077:  BCF    05.0
0078:  BCF    03.5
0079:  BSF    05.0
....................    else                  output_low(D7);        //Caso contr치rio desliga a linha 
007A:  GOTO   07F
007B:  BSF    03.5
007C:  BCF    05.0
007D:  BCF    03.5
007E:  BCF    05.0
....................  
....................    if (dado & 0b00000100) output_high(D6);         //Se o bit estiver em 1 liga a sa칤da 
007F:  BTFSS  23.2
0080:  GOTO   086
0081:  BSF    03.5
0082:  BCF    05.1
0083:  BCF    03.5
0084:  BSF    05.1
....................    else                output_low(D6);         //Caso contr치rio desliga a linha 
0085:  GOTO   08A
0086:  BSF    03.5
0087:  BCF    05.1
0088:  BCF    03.5
0089:  BCF    05.1
....................  
....................    if (dado & 0b00000010) output_high(D5);         //Se o bit estiver em 1 liga a sa칤da 
008A:  BTFSS  23.1
008B:  GOTO   091
008C:  BSF    03.5
008D:  BCF    05.2
008E:  BCF    03.5
008F:  BSF    05.2
....................    else               output_low(D5);         //Caso contr치rio desliga a linha 
0090:  GOTO   095
0091:  BSF    03.5
0092:  BCF    05.2
0093:  BCF    03.5
0094:  BCF    05.2
....................  
....................    if (dado & 0b00000001) output_high(D4);        //Se o bit estiver em 1 liga a sa칤da 
0095:  BTFSS  23.0
0096:  GOTO   09C
0097:  BSF    03.5
0098:  BCF    05.3
0099:  BCF    03.5
009A:  BSF    05.3
....................    else                 output_low(D4);         //Caso contr치rio desliga a linha 
009B:  GOTO   0A0
009C:  BSF    03.5
009D:  BCF    05.3
009E:  BCF    03.5
009F:  BCF    05.3
....................  
....................    delay_us(100); 
00A0:  MOVLW  85
00A1:  MOVWF  77
00A2:  DECFSZ 77,F
00A3:  GOTO   0A2
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
00A4:  BSF    03.5
00A5:  BCF    05.5
00A6:  BCF    03.5
00A7:  BSF    05.5
....................    delay_us(150);                                       //Aguarda 150 us 
00A8:  MOVLW  C7
00A9:  MOVWF  77
00AA:  DECFSZ 77,F
00AB:  GOTO   0AA
00AC:  GOTO   0AD
....................    output_low(EN); 
00AD:  BSF    03.5
00AE:  BCF    05.5
00AF:  BCF    03.5
00B0:  BCF    05.5
....................  
....................    delay_ms(5);                                      //Faz a inicializa칞칚o do display 
00B1:  MOVLW  05
00B2:  MOVWF  26
00B3:  CALL   055
....................  
.................... } 
00B4:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Comando para o LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void lcd_inst(unsigned char dado) 
.................... { 
....................    output_low(RS);                                 //Limpa o pino RS, modo comando 
00B5:  BCF    20.0
00B6:  MOVF   20,W
00B7:  BSF    03.5
00B8:  MOVWF  07
00B9:  BCF    03.5
00BA:  BCF    07.0
....................    delay_us(100); 
00BB:  MOVLW  85
00BC:  MOVWF  77
00BD:  DECFSZ 77,F
00BE:  GOTO   0BD
....................  
....................    if (dado & 0b10000000) output_high(D7);         //Se o bit estiver em 1 liga a sa칤da 
00BF:  BTFSS  23.7
00C0:  GOTO   0C6
00C1:  BSF    03.5
00C2:  BCF    05.0
00C3:  BCF    03.5
00C4:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr치rio desliga a linha 
00C5:  GOTO   0CA
00C6:  BSF    03.5
00C7:  BCF    05.0
00C8:  BCF    03.5
00C9:  BCF    05.0
....................  
....................    if (dado & 0b01000000) output_high(D6);         //Se o bit estiver em 1 liga a sa칤da 
00CA:  BTFSS  23.6
00CB:  GOTO   0D1
00CC:  BSF    03.5
00CD:  BCF    05.1
00CE:  BCF    03.5
00CF:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr치rio desliga a linha 
00D0:  GOTO   0D5
00D1:  BSF    03.5
00D2:  BCF    05.1
00D3:  BCF    03.5
00D4:  BCF    05.1
....................  
....................    if (dado & 0b00100000) output_high(D5);         //Se o bit estiver em 1 liga a sa칤da 
00D5:  BTFSS  23.5
00D6:  GOTO   0DC
00D7:  BSF    03.5
00D8:  BCF    05.2
00D9:  BCF    03.5
00DA:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr치rio desliga a linha 
00DB:  GOTO   0E0
00DC:  BSF    03.5
00DD:  BCF    05.2
00DE:  BCF    03.5
00DF:  BCF    05.2
....................  
....................    if (dado & 0b00010000) output_high(D4);         //Se o bit estiver em 1 liga a sa칤da 
00E0:  BTFSS  23.4
00E1:  GOTO   0E7
00E2:  BSF    03.5
00E3:  BCF    05.3
00E4:  BCF    03.5
00E5:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr치rio desliga a linha 
00E6:  GOTO   0EB
00E7:  BSF    03.5
00E8:  BCF    05.3
00E9:  BCF    03.5
00EA:  BCF    05.3
....................  
....................    delay_us(100); 
00EB:  MOVLW  85
00EC:  MOVWF  77
00ED:  DECFSZ 77,F
00EE:  GOTO   0ED
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
00EF:  BSF    03.5
00F0:  BCF    05.5
00F1:  BCF    03.5
00F2:  BSF    05.5
....................    delay_us(1);                                       //Aguarda 150 us 
00F3:  GOTO   0F4
00F4:  GOTO   0F5
....................    output_low(EN); 
00F5:  BSF    03.5
00F6:  BCF    05.5
00F7:  BCF    03.5
00F8:  BCF    05.5
....................  
....................    if (dado & 0b00001000) output_high(D7);         //Se o bit estiver em 1 liga a sa칤da 
00F9:  BTFSS  23.3
00FA:  GOTO   100
00FB:  BSF    03.5
00FC:  BCF    05.0
00FD:  BCF    03.5
00FE:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr치rio desliga a linha 
00FF:  GOTO   104
0100:  BSF    03.5
0101:  BCF    05.0
0102:  BCF    03.5
0103:  BCF    05.0
....................  
....................    if (dado & 0b00000100) output_high(D6);         //Se o bit estiver em 1 liga a sa칤da 
0104:  BTFSS  23.2
0105:  GOTO   10B
0106:  BSF    03.5
0107:  BCF    05.1
0108:  BCF    03.5
0109:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr치rio desliga a linha 
010A:  GOTO   10F
010B:  BSF    03.5
010C:  BCF    05.1
010D:  BCF    03.5
010E:  BCF    05.1
....................  
....................    if (dado & 0b00000010) output_high(D5);         //Se o bit estiver em 1 liga a sa칤da 
010F:  BTFSS  23.1
0110:  GOTO   116
0111:  BSF    03.5
0112:  BCF    05.2
0113:  BCF    03.5
0114:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr치rio desliga a linha 
0115:  GOTO   11A
0116:  BSF    03.5
0117:  BCF    05.2
0118:  BCF    03.5
0119:  BCF    05.2
....................  
....................    if (dado & 0b00000001) output_high(D4);         //Se o bit estiver em 1 liga a sa칤da 
011A:  BTFSS  23.0
011B:  GOTO   121
011C:  BSF    03.5
011D:  BCF    05.3
011E:  BCF    03.5
011F:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr치rio desliga a linha 
0120:  GOTO   125
0121:  BSF    03.5
0122:  BCF    05.3
0123:  BCF    03.5
0124:  BCF    05.3
....................  
....................  
....................    delay_us(10); 
0125:  MOVLW  0D
0126:  MOVWF  77
0127:  DECFSZ 77,F
0128:  GOTO   127
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
0129:  BSF    03.5
012A:  BCF    05.5
012B:  BCF    03.5
012C:  BSF    05.5
....................    delay_us(150);                                       //Aguarda 150 us 
012D:  MOVLW  C7
012E:  MOVWF  77
012F:  DECFSZ 77,F
0130:  GOTO   12F
0131:  GOTO   132
....................    output_low(EN); 
0132:  BSF    03.5
0133:  BCF    05.5
0134:  BCF    03.5
0135:  BCF    05.5
....................  
....................    delay_ms(5);                                     //Faz a inicializa칞칚o do display 
0136:  MOVLW  05
0137:  MOVWF  26
0138:  CALL   055
....................  
.................... } 
0139:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Dados para o LCD                * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado(char dado) 
.................... { 
....................  
....................    output_high(RS);                                 //Limpa o pino RS, modo comando 
*
016D:  BCF    20.0
016E:  MOVF   20,W
016F:  BSF    03.5
0170:  MOVWF  07
0171:  BCF    03.5
0172:  BSF    07.0
....................    delay_us(100); 
0173:  MOVLW  85
0174:  MOVWF  77
0175:  DECFSZ 77,F
0176:  GOTO   175
....................  
....................    if (dado & 0b10000000) output_high(D7);         //Se o bit estiver em 1 liga a sa칤da 
0177:  BTFSS  25.7
0178:  GOTO   17E
0179:  BSF    03.5
017A:  BCF    05.0
017B:  BCF    03.5
017C:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr치rio desliga a linha 
017D:  GOTO   182
017E:  BSF    03.5
017F:  BCF    05.0
0180:  BCF    03.5
0181:  BCF    05.0
....................  
....................    if (dado & 0b01000000) output_high(D6);         //Se o bit estiver em 1 liga a sa칤da 
0182:  BTFSS  25.6
0183:  GOTO   189
0184:  BSF    03.5
0185:  BCF    05.1
0186:  BCF    03.5
0187:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr치rio desliga a linha 
0188:  GOTO   18D
0189:  BSF    03.5
018A:  BCF    05.1
018B:  BCF    03.5
018C:  BCF    05.1
....................  
....................    if (dado & 0b00100000) output_high(D5);         //Se o bit estiver em 1 liga a sa칤da 
018D:  BTFSS  25.5
018E:  GOTO   194
018F:  BSF    03.5
0190:  BCF    05.2
0191:  BCF    03.5
0192:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr치rio desliga a linha 
0193:  GOTO   198
0194:  BSF    03.5
0195:  BCF    05.2
0196:  BCF    03.5
0197:  BCF    05.2
....................  
....................    if (dado & 0b00010000) output_high(D4);         //Se o bit estiver em 1 liga a sa칤da 
0198:  BTFSS  25.4
0199:  GOTO   19F
019A:  BSF    03.5
019B:  BCF    05.3
019C:  BCF    03.5
019D:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr치rio desliga a linha 
019E:  GOTO   1A3
019F:  BSF    03.5
01A0:  BCF    05.3
01A1:  BCF    03.5
01A2:  BCF    05.3
....................  
....................    delay_us(10); 
01A3:  MOVLW  0D
01A4:  MOVWF  77
01A5:  DECFSZ 77,F
01A6:  GOTO   1A5
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
01A7:  BSF    03.5
01A8:  BCF    05.5
01A9:  BCF    03.5
01AA:  BSF    05.5
....................    delay_us(1);                                       //Aguarda 150 us 
01AB:  GOTO   1AC
01AC:  GOTO   1AD
....................    output_low(EN); 
01AD:  BSF    03.5
01AE:  BCF    05.5
01AF:  BCF    03.5
01B0:  BCF    05.5
....................  
....................    if (dado & 0b00001000) output_high(D7);         //Se o bit estiver em 1 liga a sa칤da 
01B1:  BTFSS  25.3
01B2:  GOTO   1B8
01B3:  BSF    03.5
01B4:  BCF    05.0
01B5:  BCF    03.5
01B6:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr치rio desliga a linha 
01B7:  GOTO   1BC
01B8:  BSF    03.5
01B9:  BCF    05.0
01BA:  BCF    03.5
01BB:  BCF    05.0
....................  
....................    if (dado & 0b00000100) output_high(D6);         //Se o bit estiver em 1 liga a sa칤da 
01BC:  BTFSS  25.2
01BD:  GOTO   1C3
01BE:  BSF    03.5
01BF:  BCF    05.1
01C0:  BCF    03.5
01C1:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr치rio desliga a linha 
01C2:  GOTO   1C7
01C3:  BSF    03.5
01C4:  BCF    05.1
01C5:  BCF    03.5
01C6:  BCF    05.1
....................  
....................    if (dado & 0b00000010) output_high(D5);         //Se o bit estiver em 1 liga a sa칤da 
01C7:  BTFSS  25.1
01C8:  GOTO   1CE
01C9:  BSF    03.5
01CA:  BCF    05.2
01CB:  BCF    03.5
01CC:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr치rio desliga a linha 
01CD:  GOTO   1D2
01CE:  BSF    03.5
01CF:  BCF    05.2
01D0:  BCF    03.5
01D1:  BCF    05.2
....................  
....................    if (dado & 0b00000001) output_high(D4);         //Se o bit estiver em 1 liga a sa칤da 
01D2:  BTFSS  25.0
01D3:  GOTO   1D9
01D4:  BSF    03.5
01D5:  BCF    05.3
01D6:  BCF    03.5
01D7:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr치rio desliga a linha 
01D8:  GOTO   1DD
01D9:  BSF    03.5
01DA:  BCF    05.3
01DB:  BCF    03.5
01DC:  BCF    05.3
....................  
....................  
....................    delay_us(10); 
01DD:  MOVLW  0D
01DE:  MOVWF  77
01DF:  DECFSZ 77,F
01E0:  GOTO   1DF
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
01E1:  BSF    03.5
01E2:  BCF    05.5
01E3:  BCF    03.5
01E4:  BSF    05.5
....................    delay_us(150);                                       //Aguarda 150 us 
01E5:  MOVLW  C7
01E6:  MOVWF  77
01E7:  DECFSZ 77,F
01E8:  GOTO   1E7
01E9:  GOTO   1EA
....................    output_low(EN); 
01EA:  BSF    03.5
01EB:  BCF    05.5
01EC:  BCF    03.5
01ED:  BCF    05.5
....................  
....................    delay_ms(3);                                     //Faz a inicializa칞칚o do display 
01EE:  MOVLW  03
01EF:  MOVWF  26
01F0:  CALL   055
....................  
.................... } 
01F1:  RETLW  00
....................  
....................  
.................... #include <funcoes.c> 
.................... #define rele1    PIN_C4  
.................... #define rele2    PIN_C5  
.................... #define rele3    PIN_C6 
.................... #define led_vermelho PIN_B6  //fincionamento bloqueado 
.................... #define led_verde    PIN_B7  //fincionando normal 
.................... //******************************************************************************************************************* 
.................... void func_normal() 
.................... { 
....................  output_high(rele1); 
*
0212:  BCF    20.4
0213:  MOVF   20,W
0214:  BSF    03.5
0215:  MOVWF  07
0216:  BCF    03.5
0217:  BSF    07.4
....................  output_high(rele2); 
0218:  BCF    20.5
0219:  MOVF   20,W
021A:  BSF    03.5
021B:  MOVWF  07
021C:  BCF    03.5
021D:  BSF    07.5
....................  output_high(rele3); 
021E:  BCF    20.6
021F:  MOVF   20,W
0220:  BSF    03.5
0221:  MOVWF  07
0222:  BCF    03.5
0223:  BSF    07.6
....................  output_high(led_verde); 
0224:  BSF    03.5
0225:  BCF    06.7
0226:  BCF    03.5
0227:  BSF    06.7
....................  lcd_inst(0x80); 
0228:  MOVLW  80
0229:  MOVWF  23
022A:  CALL   0B5
....................  printf(Lcd_Dado,"  FUNC_NORMAL   "); 
022B:  CLRF   23
022C:  MOVF   23,W
022D:  CALL   004
022E:  INCF   23,F
022F:  MOVWF  77
0230:  MOVWF  25
0231:  CALL   16D
0232:  MOVLW  0D
0233:  SUBWF  23,W
0234:  BTFSS  03.2
0235:  GOTO   22C
0236:  MOVLW  03
0237:  MOVWF  24
0238:  MOVLW  20
0239:  MOVWF  25
023A:  CALL   16D
023B:  DECFSZ 24,F
023C:  GOTO   238
....................  lcd_inst(0xc0); 
023D:  MOVLW  C0
023E:  MOVWF  23
023F:  CALL   0B5
....................  printf(Lcd_Dado,"PR. TECLA P/ BLO"); 
0240:  CLRF   23
0241:  MOVF   23,W
0242:  CALL   016
0243:  INCF   23,F
0244:  MOVWF  77
0245:  MOVWF  25
0246:  CALL   16D
0247:  MOVLW  10
0248:  SUBWF  23,W
0249:  BTFSS  03.2
024A:  GOTO   241
....................  while(!teclado()); 
024B:  CALL   1F2
024C:  MOVF   78,F
024D:  BTFSC  03.2
024E:  GOTO   24B
....................  
.................... } 
024F:  BCF    0A.3
0250:  BCF    0A.4
0251:  GOTO   2A0 (RETURN)
.................... //****************************************************************************************************************** 
.................... void func_bloqueado() 
.................... { 
....................  output_low(rele1); 
0252:  BCF    20.4
0253:  MOVF   20,W
0254:  BSF    03.5
0255:  MOVWF  07
0256:  BCF    03.5
0257:  BCF    07.4
....................  output_low(rele2); 
0258:  BCF    20.5
0259:  MOVF   20,W
025A:  BSF    03.5
025B:  MOVWF  07
025C:  BCF    03.5
025D:  BCF    07.5
....................  output_low(rele3); 
025E:  BCF    20.6
025F:  MOVF   20,W
0260:  BSF    03.5
0261:  MOVWF  07
0262:  BCF    03.5
0263:  BCF    07.6
....................  output_high(led_vermelho); 
0264:  BSF    03.5
0265:  BCF    06.6
0266:  BCF    03.5
0267:  BSF    06.6
....................  lcd_inst(0x80); 
0268:  MOVLW  80
0269:  MOVWF  23
026A:  CALL   0B5
....................  printf(Lcd_Dado," FUNC_BLOQUEADO "); 
026B:  CLRF   23
026C:  MOVF   23,W
026D:  CALL   02B
026E:  INCF   23,F
026F:  MOVWF  77
0270:  MOVWF  25
0271:  CALL   16D
0272:  MOVLW  10
0273:  SUBWF  23,W
0274:  BTFSS  03.2
0275:  GOTO   26C
....................  lcd_inst(0xc0); 
0276:  MOVLW  C0
0277:  MOVWF  23
0278:  CALL   0B5
....................  printf(Lcd_Dado,"PR. TECLA P/ DES"); 
0279:  CLRF   23
027A:  MOVF   23,W
027B:  CALL   040
027C:  INCF   23,F
027D:  MOVWF  77
027E:  MOVWF  25
027F:  CALL   16D
0280:  MOVLW  10
0281:  SUBWF  23,W
0282:  BTFSS  03.2
0283:  GOTO   27A
....................  while(!teclado()); 
0284:  CALL   1F2
0285:  MOVF   78,F
0286:  BTFSC  03.2
0287:  GOTO   284
.................... } 
0288:  BCF    0A.3
0289:  BCF    0A.4
028A:  GOTO   2A2 (RETURN)
.................... //****************************************************************************************************************** 
....................  
....................  
.................... char i; 
.................... int1 bloqueio=0;//indica se a maquina ja tem um bloqueio pendente (0>sim   1>nao) 
*
0299:  BCF    22.0
....................  
.................... void main() 
.................... { 
*
028B:  CLRF   04
028C:  BCF    03.7
028D:  MOVLW  1F
028E:  ANDWF  03,F
028F:  BSF    03.5
0290:  BSF    1F.0
0291:  BSF    1F.1
0292:  BSF    1F.2
0293:  BCF    1F.3
0294:  MOVLW  07
0295:  MOVWF  1C
....................    inicializa_lcd(); 
*
029A:  GOTO   13A
....................    port_b_pullups(true); 
029B:  BSF    03.5
029C:  BCF    01.7
....................    while(1) 
....................    { 
....................    if(!bloqueio)func_normal();  //se bloqueio for==1  
029D:  BCF    03.5
029E:  BTFSS  22.0
029F:  GOTO   212
....................    if(bloqueio)func_bloqueado();//se bloqueio for==0 
02A0:  BTFSC  22.0
02A1:  GOTO   252
....................    } 
02A2:  GOTO   29E
.................... } 
02A3:  SLEEP

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
