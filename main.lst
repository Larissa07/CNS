CCS PCM C Compiler, Version 4.038, 61973               05-ago-11 07:55

               Filename: C:\Documents and Settings\eletronica\CNS\main.lst

               ROM used: 847 words (10%)
                         Largest free fragment is 2048
               RAM used: 21 (6%) at main() level
                         23 (6%) worst case
               Stack:    3 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   313
0003:  NOP
.................... #include <16f876a.h> 
.................... //////// Standard Header file for the PIC16F876A device //////////////// 
.................... #device PIC16F876A 
.................... #list 
....................  
.................... #use delay(clock=16000000) 
0082:  MOVLW  30
0083:  MOVWF  04
0084:  BCF    03.7
0085:  MOVF   00,W
0086:  BTFSC  03.2
0087:  GOTO   096
0088:  MOVLW  05
0089:  MOVWF  78
008A:  CLRF   77
008B:  DECFSZ 77,F
008C:  GOTO   08B
008D:  DECFSZ 78,F
008E:  GOTO   08A
008F:  MOVLW  2E
0090:  MOVWF  77
0091:  DECFSZ 77,F
0092:  GOTO   091
0093:  GOTO   094
0094:  DECFSZ 00,F
0095:  GOTO   088
0096:  RETLW  00
.................... #include <teclado.c> 
.................... #define baixo    PIN_B4 
.................... #define direita  PIN_B5 
.................... #define esquerda PIN_B2 
.................... #define cima     PIN_B3 
....................  
.................... char teclado() 
.................... { 
....................    char tecla=0; 
*
027A:  CLRF   2C
....................    if(!input(cima))tecla=1; 
027B:  BSF    03.5
027C:  BSF    06.3
027D:  BCF    03.5
027E:  BTFSC  06.3
027F:  GOTO   282
0280:  MOVLW  01
0281:  MOVWF  2C
....................    if(!input(esquerda))tecla=2; 
0282:  BSF    03.5
0283:  BSF    06.2
0284:  BCF    03.5
0285:  BTFSC  06.2
0286:  GOTO   289
0287:  MOVLW  02
0288:  MOVWF  2C
....................    if(!input(direita))tecla=3; 
0289:  BSF    03.5
028A:  BSF    06.5
028B:  BCF    03.5
028C:  BTFSC  06.5
028D:  GOTO   290
028E:  MOVLW  03
028F:  MOVWF  2C
....................    if(!input(baixo))tecla=4; 
0290:  BSF    03.5
0291:  BSF    06.4
0292:  BCF    03.5
0293:  BTFSC  06.4
0294:  GOTO   297
0295:  MOVLW  04
0296:  MOVWF  2C
....................    return tecla; 
0297:  MOVF   2C,W
0298:  MOVWF  78
.................... } 
0299:  RETLW  00
....................  
.................... #include <lcd_modificado.c> 
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *                                                                     * 
....................  *             Rotina Gen√©rica de Manipula√ß√£o de LCD 16x2              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
.................... // Defina os pinos que est√£o ligados fisicamente 
....................  
.................... #define  RS    PIN_C0    // Pino de sele√ß√£o de modo do display 
.................... #define  EN    PIN_A5    // Pino de habilita√ß√£o do display 
.................... #define  D7    PIN_A0   // Pino de dados 7 
.................... #define  D6    PIN_A1    // Pino de dados 6 
.................... #define  D5    PIN_A2    // Pino de dados 5 
.................... #define  D4    PIN_A3    // Pino de dados 4 
....................  
.................... //protÛtipo das funÁıes 
.................... void lcd_inst4(unsigned char dado); 
.................... void lcd_inst(unsigned char dado); 
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                      Rotina de Inicializa√ß√£o de LCD                 * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
....................  
.................... void inicializa_lcd(void) 
.................... { 
....................  
....................    lcd_inst4(0b00000011); 
*
0167:  MOVLW  03
0168:  MOVWF  2C
0169:  CALL   097
....................    delay_ms(15); 
016A:  MOVLW  0F
016B:  MOVWF  30
016C:  CALL   082
....................    lcd_inst4(0b00000011); 
016D:  MOVLW  03
016E:  MOVWF  2C
016F:  CALL   097
....................    delay_ms(15); 
0170:  MOVLW  0F
0171:  MOVWF  30
0172:  CALL   082
....................    lcd_inst4(0b00000011); 
0173:  MOVLW  03
0174:  MOVWF  2C
0175:  CALL   097
....................    delay_ms(15); 
0176:  MOVLW  0F
0177:  MOVWF  30
0178:  CALL   082
....................    lcd_inst4(0b00000010); 
0179:  MOVLW  02
017A:  MOVWF  2C
017B:  CALL   097
....................    delay_ms(15); 
017C:  MOVLW  0F
017D:  MOVWF  30
017E:  CALL   082
....................  
....................    lcd_inst(0b00101000); 
017F:  MOVLW  28
0180:  MOVWF  2C
0181:  CALL   0E2
....................    delay_ms(15); 
0182:  MOVLW  0F
0183:  MOVWF  30
0184:  CALL   082
....................    lcd_inst(0b00001100); 
0185:  MOVLW  0C
0186:  MOVWF  2C
0187:  CALL   0E2
....................    delay_ms(15); 
0188:  MOVLW  0F
0189:  MOVWF  30
018A:  CALL   082
....................    lcd_inst(0b00000110); 
018B:  MOVLW  06
018C:  MOVWF  2C
018D:  CALL   0E2
....................    delay_ms(15); 
018E:  MOVLW  0F
018F:  MOVWF  30
0190:  CALL   082
....................    lcd_inst(0b00000001); 
0191:  MOVLW  01
0192:  MOVWF  2C
0193:  CALL   0E2
....................    delay_ms(100); 
0194:  MOVLW  64
0195:  MOVWF  30
0196:  CALL   082
.................... } 
0197:  BCF    0A.3
0198:  BCF    0A.4
0199:  GOTO   329 (RETURN)
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Comando para o LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void lcd_inst4(unsigned char dado) 
.................... { 
....................  
....................    output_low(RS);                          //Limpa o pino RS, modo comando 
*
0097:  BCF    20.0
0098:  MOVF   20,W
0099:  BSF    03.5
009A:  MOVWF  07
009B:  BCF    03.5
009C:  BCF    07.0
*
031E:  MOVLW  FF
031F:  BCF    03.5
0320:  MOVWF  20
....................    delay_us(100); 
*
009D:  MOVLW  85
009E:  MOVWF  77
009F:  DECFSZ 77,F
00A0:  GOTO   09F
....................  
....................    if (dado & 0b00001000) output_high(D7);         //Se o bit estiver em 1 liga a sa√≠da 
00A1:  BTFSS  2C.3
00A2:  GOTO   0A8
00A3:  BSF    03.5
00A4:  BCF    05.0
00A5:  BCF    03.5
00A6:  BSF    05.0
....................    else                  output_low(D7);        //Caso contr√°rio desliga a linha 
00A7:  GOTO   0AC
00A8:  BSF    03.5
00A9:  BCF    05.0
00AA:  BCF    03.5
00AB:  BCF    05.0
....................  
....................    if (dado & 0b00000100) output_high(D6);         //Se o bit estiver em 1 liga a sa√≠da 
00AC:  BTFSS  2C.2
00AD:  GOTO   0B3
00AE:  BSF    03.5
00AF:  BCF    05.1
00B0:  BCF    03.5
00B1:  BSF    05.1
....................    else                output_low(D6);         //Caso contr√°rio desliga a linha 
00B2:  GOTO   0B7
00B3:  BSF    03.5
00B4:  BCF    05.1
00B5:  BCF    03.5
00B6:  BCF    05.1
....................  
....................    if (dado & 0b00000010) output_high(D5);         //Se o bit estiver em 1 liga a sa√≠da 
00B7:  BTFSS  2C.1
00B8:  GOTO   0BE
00B9:  BSF    03.5
00BA:  BCF    05.2
00BB:  BCF    03.5
00BC:  BSF    05.2
....................    else               output_low(D5);         //Caso contr√°rio desliga a linha 
00BD:  GOTO   0C2
00BE:  BSF    03.5
00BF:  BCF    05.2
00C0:  BCF    03.5
00C1:  BCF    05.2
....................  
....................    if (dado & 0b00000001) output_high(D4);        //Se o bit estiver em 1 liga a sa√≠da 
00C2:  BTFSS  2C.0
00C3:  GOTO   0C9
00C4:  BSF    03.5
00C5:  BCF    05.3
00C6:  BCF    03.5
00C7:  BSF    05.3
....................    else                 output_low(D4);         //Caso contr√°rio desliga a linha 
00C8:  GOTO   0CD
00C9:  BSF    03.5
00CA:  BCF    05.3
00CB:  BCF    03.5
00CC:  BCF    05.3
....................  
....................    delay_us(100); 
00CD:  MOVLW  85
00CE:  MOVWF  77
00CF:  DECFSZ 77,F
00D0:  GOTO   0CF
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
00D1:  BSF    03.5
00D2:  BCF    05.5
00D3:  BCF    03.5
00D4:  BSF    05.5
....................    delay_us(150);                                       //Aguarda 150 us 
00D5:  MOVLW  C7
00D6:  MOVWF  77
00D7:  DECFSZ 77,F
00D8:  GOTO   0D7
00D9:  GOTO   0DA
....................    output_low(EN); 
00DA:  BSF    03.5
00DB:  BCF    05.5
00DC:  BCF    03.5
00DD:  BCF    05.5
....................  
....................    delay_ms(5);                                      //Faz a inicializa√ß√£o do display 
00DE:  MOVLW  05
00DF:  MOVWF  30
00E0:  CALL   082
....................  
.................... } 
00E1:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Comando para o LCD              * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void lcd_inst(unsigned char dado) 
.................... { 
....................    output_low(RS);                                 //Limpa o pino RS, modo comando 
00E2:  BCF    20.0
00E3:  MOVF   20,W
00E4:  BSF    03.5
00E5:  MOVWF  07
00E6:  BCF    03.5
00E7:  BCF    07.0
....................    delay_us(100); 
00E8:  MOVLW  85
00E9:  MOVWF  77
00EA:  DECFSZ 77,F
00EB:  GOTO   0EA
....................  
....................    if (dado & 0b10000000) output_high(D7);         //Se o bit estiver em 1 liga a sa√≠da 
00EC:  BTFSS  2C.7
00ED:  GOTO   0F3
00EE:  BSF    03.5
00EF:  BCF    05.0
00F0:  BCF    03.5
00F1:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr√°rio desliga a linha 
00F2:  GOTO   0F7
00F3:  BSF    03.5
00F4:  BCF    05.0
00F5:  BCF    03.5
00F6:  BCF    05.0
....................  
....................    if (dado & 0b01000000) output_high(D6);         //Se o bit estiver em 1 liga a sa√≠da 
00F7:  BTFSS  2C.6
00F8:  GOTO   0FE
00F9:  BSF    03.5
00FA:  BCF    05.1
00FB:  BCF    03.5
00FC:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr√°rio desliga a linha 
00FD:  GOTO   102
00FE:  BSF    03.5
00FF:  BCF    05.1
0100:  BCF    03.5
0101:  BCF    05.1
....................  
....................    if (dado & 0b00100000) output_high(D5);         //Se o bit estiver em 1 liga a sa√≠da 
0102:  BTFSS  2C.5
0103:  GOTO   109
0104:  BSF    03.5
0105:  BCF    05.2
0106:  BCF    03.5
0107:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr√°rio desliga a linha 
0108:  GOTO   10D
0109:  BSF    03.5
010A:  BCF    05.2
010B:  BCF    03.5
010C:  BCF    05.2
....................  
....................    if (dado & 0b00010000) output_high(D4);         //Se o bit estiver em 1 liga a sa√≠da 
010D:  BTFSS  2C.4
010E:  GOTO   114
010F:  BSF    03.5
0110:  BCF    05.3
0111:  BCF    03.5
0112:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr√°rio desliga a linha 
0113:  GOTO   118
0114:  BSF    03.5
0115:  BCF    05.3
0116:  BCF    03.5
0117:  BCF    05.3
....................  
....................    delay_us(100); 
0118:  MOVLW  85
0119:  MOVWF  77
011A:  DECFSZ 77,F
011B:  GOTO   11A
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
011C:  BSF    03.5
011D:  BCF    05.5
011E:  BCF    03.5
011F:  BSF    05.5
....................    delay_us(1);                                       //Aguarda 150 us 
0120:  GOTO   121
0121:  GOTO   122
....................    output_low(EN); 
0122:  BSF    03.5
0123:  BCF    05.5
0124:  BCF    03.5
0125:  BCF    05.5
....................  
....................    if (dado & 0b00001000) output_high(D7);         //Se o bit estiver em 1 liga a sa√≠da 
0126:  BTFSS  2C.3
0127:  GOTO   12D
0128:  BSF    03.5
0129:  BCF    05.0
012A:  BCF    03.5
012B:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr√°rio desliga a linha 
012C:  GOTO   131
012D:  BSF    03.5
012E:  BCF    05.0
012F:  BCF    03.5
0130:  BCF    05.0
....................  
....................    if (dado & 0b00000100) output_high(D6);         //Se o bit estiver em 1 liga a sa√≠da 
0131:  BTFSS  2C.2
0132:  GOTO   138
0133:  BSF    03.5
0134:  BCF    05.1
0135:  BCF    03.5
0136:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr√°rio desliga a linha 
0137:  GOTO   13C
0138:  BSF    03.5
0139:  BCF    05.1
013A:  BCF    03.5
013B:  BCF    05.1
....................  
....................    if (dado & 0b00000010) output_high(D5);         //Se o bit estiver em 1 liga a sa√≠da 
013C:  BTFSS  2C.1
013D:  GOTO   143
013E:  BSF    03.5
013F:  BCF    05.2
0140:  BCF    03.5
0141:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr√°rio desliga a linha 
0142:  GOTO   147
0143:  BSF    03.5
0144:  BCF    05.2
0145:  BCF    03.5
0146:  BCF    05.2
....................  
....................    if (dado & 0b00000001) output_high(D4);         //Se o bit estiver em 1 liga a sa√≠da 
0147:  BTFSS  2C.0
0148:  GOTO   14E
0149:  BSF    03.5
014A:  BCF    05.3
014B:  BCF    03.5
014C:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr√°rio desliga a linha 
014D:  GOTO   152
014E:  BSF    03.5
014F:  BCF    05.3
0150:  BCF    03.5
0151:  BCF    05.3
....................  
....................  
....................    delay_us(10); 
0152:  MOVLW  0D
0153:  MOVWF  77
0154:  DECFSZ 77,F
0155:  GOTO   154
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
0156:  BSF    03.5
0157:  BCF    05.5
0158:  BCF    03.5
0159:  BSF    05.5
....................    delay_us(150);                                       //Aguarda 150 us 
015A:  MOVLW  C7
015B:  MOVWF  77
015C:  DECFSZ 77,F
015D:  GOTO   15C
015E:  GOTO   15F
....................    output_low(EN); 
015F:  BSF    03.5
0160:  BCF    05.5
0161:  BCF    03.5
0162:  BCF    05.5
....................  
....................    delay_ms(5);                                     //Faz a inicializa√ß√£o do display 
0163:  MOVLW  05
0164:  MOVWF  30
0165:  CALL   082
....................  
.................... } 
0166:  RETLW  00
....................  
.................... /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
....................  *                  Rotina de Envio de Dados para o LCD                * 
....................  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
....................  
.................... void Lcd_Dado(char dado) 
.................... { 
....................  
....................    output_high(RS);                                 //Limpa o pino RS, modo comando 
*
019A:  BCF    20.0
019B:  MOVF   20,W
019C:  BSF    03.5
019D:  MOVWF  07
019E:  BCF    03.5
019F:  BSF    07.0
....................    delay_us(100); 
01A0:  MOVLW  85
01A1:  MOVWF  77
01A2:  DECFSZ 77,F
01A3:  GOTO   1A2
....................  
....................    if (dado & 0b10000000) output_high(D7);         //Se o bit estiver em 1 liga a sa√≠da 
01A4:  BTFSS  2F.7
01A5:  GOTO   1AB
01A6:  BSF    03.5
01A7:  BCF    05.0
01A8:  BCF    03.5
01A9:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr√°rio desliga a linha 
01AA:  GOTO   1AF
01AB:  BSF    03.5
01AC:  BCF    05.0
01AD:  BCF    03.5
01AE:  BCF    05.0
....................  
....................    if (dado & 0b01000000) output_high(D6);         //Se o bit estiver em 1 liga a sa√≠da 
01AF:  BTFSS  2F.6
01B0:  GOTO   1B6
01B1:  BSF    03.5
01B2:  BCF    05.1
01B3:  BCF    03.5
01B4:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr√°rio desliga a linha 
01B5:  GOTO   1BA
01B6:  BSF    03.5
01B7:  BCF    05.1
01B8:  BCF    03.5
01B9:  BCF    05.1
....................  
....................    if (dado & 0b00100000) output_high(D5);         //Se o bit estiver em 1 liga a sa√≠da 
01BA:  BTFSS  2F.5
01BB:  GOTO   1C1
01BC:  BSF    03.5
01BD:  BCF    05.2
01BE:  BCF    03.5
01BF:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr√°rio desliga a linha 
01C0:  GOTO   1C5
01C1:  BSF    03.5
01C2:  BCF    05.2
01C3:  BCF    03.5
01C4:  BCF    05.2
....................  
....................    if (dado & 0b00010000) output_high(D4);         //Se o bit estiver em 1 liga a sa√≠da 
01C5:  BTFSS  2F.4
01C6:  GOTO   1CC
01C7:  BSF    03.5
01C8:  BCF    05.3
01C9:  BCF    03.5
01CA:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr√°rio desliga a linha 
01CB:  GOTO   1D0
01CC:  BSF    03.5
01CD:  BCF    05.3
01CE:  BCF    03.5
01CF:  BCF    05.3
....................  
....................    delay_us(10); 
01D0:  MOVLW  0D
01D1:  MOVWF  77
01D2:  DECFSZ 77,F
01D3:  GOTO   1D2
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
01D4:  BSF    03.5
01D5:  BCF    05.5
01D6:  BCF    03.5
01D7:  BSF    05.5
....................    delay_us(1);                                       //Aguarda 150 us 
01D8:  GOTO   1D9
01D9:  GOTO   1DA
....................    output_low(EN); 
01DA:  BSF    03.5
01DB:  BCF    05.5
01DC:  BCF    03.5
01DD:  BCF    05.5
....................  
....................    if (dado & 0b00001000) output_high(D7);         //Se o bit estiver em 1 liga a sa√≠da 
01DE:  BTFSS  2F.3
01DF:  GOTO   1E5
01E0:  BSF    03.5
01E1:  BCF    05.0
01E2:  BCF    03.5
01E3:  BSF    05.0
....................    else                      output_low(D7);            //Caso contr√°rio desliga a linha 
01E4:  GOTO   1E9
01E5:  BSF    03.5
01E6:  BCF    05.0
01E7:  BCF    03.5
01E8:  BCF    05.0
....................  
....................    if (dado & 0b00000100) output_high(D6);         //Se o bit estiver em 1 liga a sa√≠da 
01E9:  BTFSS  2F.2
01EA:  GOTO   1F0
01EB:  BSF    03.5
01EC:  BCF    05.1
01ED:  BCF    03.5
01EE:  BSF    05.1
....................    else                     output_low(D6);            //Caso contr√°rio desliga a linha 
01EF:  GOTO   1F4
01F0:  BSF    03.5
01F1:  BCF    05.1
01F2:  BCF    03.5
01F3:  BCF    05.1
....................  
....................    if (dado & 0b00000010) output_high(D5);         //Se o bit estiver em 1 liga a sa√≠da 
01F4:  BTFSS  2F.1
01F5:  GOTO   1FB
01F6:  BSF    03.5
01F7:  BCF    05.2
01F8:  BCF    03.5
01F9:  BSF    05.2
....................    else                    output_low(D5);            //Caso contr√°rio desliga a linha 
01FA:  GOTO   1FF
01FB:  BSF    03.5
01FC:  BCF    05.2
01FD:  BCF    03.5
01FE:  BCF    05.2
....................  
....................    if (dado & 0b00000001) output_high(D4);         //Se o bit estiver em 1 liga a sa√≠da 
01FF:  BTFSS  2F.0
0200:  GOTO   206
0201:  BSF    03.5
0202:  BCF    05.3
0203:  BCF    03.5
0204:  BSF    05.3
....................    else                      output_low(D4);            //Caso contr√°rio desliga a linha 
0205:  GOTO   20A
0206:  BSF    03.5
0207:  BCF    05.3
0208:  BCF    03.5
0209:  BCF    05.3
....................  
....................  
....................    delay_us(10); 
020A:  MOVLW  0D
020B:  MOVWF  77
020C:  DECFSZ 77,F
020D:  GOTO   20C
....................  
....................    output_high(EN);                                    //Gera pulso de enable 
020E:  BSF    03.5
020F:  BCF    05.5
0210:  BCF    03.5
0211:  BSF    05.5
....................    delay_us(150);                                       //Aguarda 150 us 
0212:  MOVLW  C7
0213:  MOVWF  77
0214:  DECFSZ 77,F
0215:  GOTO   214
0216:  GOTO   217
....................    output_low(EN); 
0217:  BSF    03.5
0218:  BCF    05.5
0219:  BCF    03.5
021A:  BCF    05.5
....................  
....................    delay_ms(3);                                     //Faz a inicializa√ß√£o do display 
021B:  MOVLW  03
021C:  MOVWF  30
021D:  CALL   082
....................  
.................... } 
021E:  RETLW  00
....................  
....................  
.................... #include <funcoes.c> 
.................... #define rele1    PIN_C4  
.................... #define rele2    PIN_C5  
.................... #define rele3    PIN_C6 
.................... #define led_vermelho PIN_B6  //fincionamento bloqueado 
.................... #define led_verde    PIN_B7  //fincionando normal 
.................... //******************************************************************************************************************* 
.................... void func_normal() 
.................... { 
....................  output_high(rele1); 
*
029A:  BCF    20.4
029B:  MOVF   20,W
029C:  BSF    03.5
029D:  MOVWF  07
029E:  BCF    03.5
029F:  BSF    07.4
....................  output_high(rele2); 
02A0:  BCF    20.5
02A1:  MOVF   20,W
02A2:  BSF    03.5
02A3:  MOVWF  07
02A4:  BCF    03.5
02A5:  BSF    07.5
....................  output_high(rele3); 
02A6:  BCF    20.6
02A7:  MOVF   20,W
02A8:  BSF    03.5
02A9:  MOVWF  07
02AA:  BCF    03.5
02AB:  BSF    07.6
....................  output_high(led_verde); 
02AC:  BSF    03.5
02AD:  BCF    06.7
02AE:  BCF    03.5
02AF:  BSF    06.7
....................  lcd_inst(0x80); 
02B0:  MOVLW  80
02B1:  MOVWF  2C
02B2:  CALL   0E2
....................  printf(Lcd_Dado,"  FUNC_NORMAL   "); 
02B3:  CLRF   2C
02B4:  MOVF   2C,W
02B5:  CALL   004
02B6:  INCF   2C,F
02B7:  MOVWF  77
02B8:  MOVWF  2F
02B9:  CALL   19A
02BA:  MOVLW  0D
02BB:  SUBWF  2C,W
02BC:  BTFSS  03.2
02BD:  GOTO   2B4
02BE:  MOVLW  03
02BF:  MOVWF  2D
02C0:  MOVLW  20
02C1:  MOVWF  2F
02C2:  CALL   19A
02C3:  DECFSZ 2D,F
02C4:  GOTO   2C0
....................  lcd_inst(0xc0); 
02C5:  MOVLW  C0
02C6:  MOVWF  2C
02C7:  CALL   0E2
....................  printf(Lcd_Dado,"PR. TECLA P/ BLO"); 
02C8:  CLRF   2C
02C9:  MOVF   2C,W
02CA:  CALL   016
02CB:  INCF   2C,F
02CC:  MOVWF  77
02CD:  MOVWF  2F
02CE:  CALL   19A
02CF:  MOVLW  10
02D0:  SUBWF  2C,W
02D1:  BTFSS  03.2
02D2:  GOTO   2C9
....................  while(!teclado()); 
02D3:  CALL   27A
02D4:  MOVF   78,F
02D5:  BTFSC  03.2
02D6:  GOTO   2D3
....................  
.................... } 
02D7:  BCF    0A.3
02D8:  BCF    0A.4
02D9:  GOTO   34B (RETURN)
.................... //****************************************************************************************************************** 
.................... void func_bloqueado() 
.................... { 
....................  output_low(rele1); 
02DA:  BCF    20.4
02DB:  MOVF   20,W
02DC:  BSF    03.5
02DD:  MOVWF  07
02DE:  BCF    03.5
02DF:  BCF    07.4
....................  output_low(rele2); 
02E0:  BCF    20.5
02E1:  MOVF   20,W
02E2:  BSF    03.5
02E3:  MOVWF  07
02E4:  BCF    03.5
02E5:  BCF    07.5
....................  output_low(rele3); 
02E6:  BCF    20.6
02E7:  MOVF   20,W
02E8:  BSF    03.5
02E9:  MOVWF  07
02EA:  BCF    03.5
02EB:  BCF    07.6
....................  output_high(led_vermelho); 
02EC:  BSF    03.5
02ED:  BCF    06.6
02EE:  BCF    03.5
02EF:  BSF    06.6
....................  lcd_inst(0x80); 
02F0:  MOVLW  80
02F1:  MOVWF  2C
02F2:  CALL   0E2
....................  printf(Lcd_Dado," FUNC_BLOQUEADO "); 
02F3:  CLRF   2C
02F4:  MOVF   2C,W
02F5:  CALL   02B
02F6:  INCF   2C,F
02F7:  MOVWF  77
02F8:  MOVWF  2F
02F9:  CALL   19A
02FA:  MOVLW  10
02FB:  SUBWF  2C,W
02FC:  BTFSS  03.2
02FD:  GOTO   2F4
....................  lcd_inst(0xc0); 
02FE:  MOVLW  C0
02FF:  MOVWF  2C
0300:  CALL   0E2
....................  printf(Lcd_Dado,"PR. TECLA P/ DES"); 
0301:  CLRF   2C
0302:  MOVF   2C,W
0303:  CALL   040
0304:  INCF   2C,F
0305:  MOVWF  77
0306:  MOVWF  2F
0307:  CALL   19A
0308:  MOVLW  10
0309:  SUBWF  2C,W
030A:  BTFSS  03.2
030B:  GOTO   302
....................  while(!teclado()); 
030C:  CALL   27A
030D:  MOVF   78,F
030E:  BTFSC  03.2
030F:  GOTO   30C
.................... } 
0310:  BCF    0A.3
0311:  BCF    0A.4
0312:  GOTO   34D (RETURN)
.................... //****************************************************************************************************************** 
....................  
.................... #include <verifica.c> 
.................... #define ler_conf read_eeprom(255)// le o espaco 255 onde esta definido configuracao do processo 
.................... #define iniciado 128// valor que indica que o processo ja foi iniciado alguma vez 
.................... #define bloqueado 172// valor que indica que o processo esta bloqueado 
.................... char SENHA[4]={'0','0','0','0'}; 
*
0321:  MOVLW  30
0322:  MOVWF  21
0323:  MOVWF  22
0324:  MOVWF  23
0325:  MOVWF  24
.................... char digito=0; 
0326:  CLRF   25
.................... void limpa_lcd(); 
....................  
.................... struct user  
.................... { 
....................    char id; 
....................    int16 senha; 
....................    int1 block; 
....................    int1 logado; 
.................... } usuario; 
....................  
.................... void verifica() 
.................... { 
....................    if(ler_conf==iniciado) 
*
021F:  MOVLW  FF
0220:  BSF    03.6
0221:  MOVWF  0D
0222:  BSF    03.5
0223:  BCF    0C.7
0224:  BSF    0C.0
0225:  BCF    03.5
0226:  MOVF   0C,W
0227:  SUBLW  80
0228:  BTFSS  03.2
0229:  GOTO   235
....................    { 
....................        
....................       if(ler_conf==bloqueado); 
022A:  MOVLW  FF
022B:  MOVWF  0D
022C:  BSF    03.5
022D:  BCF    0C.7
022E:  BSF    0C.0
022F:  BCF    03.5
0230:  MOVF   0C,W
0231:  SUBLW  AC
0232:  BTFSC  03.2
0233:  GOTO   234
....................    } 
....................    else 
0234:  GOTO   276
....................    { 
....................       lcd_inst(0x80); 
0235:  MOVLW  80
0236:  BCF    03.6
0237:  MOVWF  2C
0238:  CALL   0E2
....................       printf(lcd_Dado," USUARIO ID: 0  "); 
0239:  CLRF   2C
023A:  MOVF   2C,W
023B:  CALL   055
023C:  INCF   2C,F
023D:  MOVWF  77
023E:  MOVWF  2F
023F:  CALL   19A
0240:  MOVLW  10
0241:  SUBWF  2C,W
0242:  BTFSS  03.2
0243:  GOTO   23A
....................       lcd_inst(0xc0); 
0244:  MOVLW  C0
0245:  MOVWF  2C
0246:  CALL   0E2
....................       printf(lcd_Dado," SENHA :        "); 
0247:  CLRF   2C
0248:  MOVF   2C,W
0249:  CALL   06A
024A:  INCF   2C,F
024B:  MOVWF  77
024C:  MOVWF  2F
024D:  CALL   19A
024E:  MOVLW  08
024F:  SUBWF  2C,W
0250:  BTFSS  03.2
0251:  GOTO   248
0252:  MOVLW  08
0253:  MOVWF  2D
0254:  MOVLW  20
0255:  MOVWF  2F
0256:  CALL   19A
0257:  DECFSZ 2D,F
0258:  GOTO   254
....................       delay_ms(2000); 
0259:  MOVLW  08
025A:  MOVWF  2C
025B:  MOVLW  FA
025C:  MOVWF  30
025D:  CALL   082
025E:  DECFSZ 2C,F
025F:  GOTO   25B
....................       limpa_lcd(); 
....................       usuario.id=0; 
*
0274:  CLRF   26
0275:  BSF    03.6
....................    } 
.................... } 
0276:  BCF    03.6
0277:  BCF    0A.3
0278:  BCF    0A.4
0279:  GOTO   349 (RETURN)
....................  
.................... /*for(i=0;i<4;i++) 
.................... { 
....................    while(!direita!=2) 
....................    { 
....................    lcd_inst(0x80); 
....................    lcd_inst(0x0d); 
....................    if(!input(cima) && digito<9)digito++; 
....................    if(!input(baixo) && digito>0)digito--; 
....................    lcd_inst(0xc0); 
....................    printf(Lcd_Dado,"%c",digito); 
....................    } 
....................    SENHA[i]=digito; 
....................     
.................... }*/ 
....................  
.................... void limpa_lcd() 
.................... { 
....................    lcd_inst(0x80); 
*
0260:  MOVLW  80
0261:  MOVWF  2C
0262:  CALL   0E2
....................    printf(lcd_Dado,"                "); 
0263:  MOVLW  10
0264:  MOVWF  2C
0265:  MOVLW  20
0266:  MOVWF  2F
0267:  CALL   19A
0268:  DECFSZ 2C,F
0269:  GOTO   265
....................    lcd_inst(0xc0); 
026A:  MOVLW  C0
026B:  MOVWF  2C
026C:  CALL   0E2
....................    printf(lcd_Dado,"                "); 
026D:  MOVLW  10
026E:  MOVWF  2C
026F:  MOVLW  20
0270:  MOVWF  2F
0271:  CALL   19A
0272:  DECFSZ 2C,F
0273:  GOTO   26F
.................... } 
....................  
.................... char i; 
.................... int1 bloqueio=0;//indica se a maquina ja tem um bloqueio pendente (0>sim   1>nao) 
*
0327:  BCF    2B.0
....................  
....................  
....................  
.................... void main() 
.................... { 
*
0313:  CLRF   04
0314:  BCF    03.7
0315:  MOVLW  1F
0316:  ANDWF  03,F
0317:  BSF    03.5
0318:  BSF    1F.0
0319:  BSF    1F.1
031A:  BSF    1F.2
031B:  BCF    1F.3
031C:  MOVLW  07
031D:  MOVWF  1C
....................    inicializa_lcd(); 
*
0328:  GOTO   167
....................    port_b_pullups(true); 
0329:  BSF    03.5
032A:  BCF    01.7
....................    lcd_inst(0x80); 
032B:  MOVLW  80
032C:  BCF    03.5
032D:  MOVWF  2C
032E:  CALL   0E2
....................    printf(lcd_Dado,"   gbfrtd      "); 
032F:  MOVLW  03
0330:  MOVWF  2C
0331:  MOVLW  20
0332:  MOVWF  2F
0333:  CALL   19A
0334:  DECFSZ 2C,F
0335:  GOTO   331
0336:  CLRF   2D
0337:  MOVF   2D,W
0338:  CALL   077
0339:  INCF   2D,F
033A:  MOVWF  77
033B:  MOVWF  2F
033C:  CALL   19A
033D:  MOVLW  06
033E:  SUBWF  2D,W
033F:  BTFSS  03.2
0340:  GOTO   337
0341:  MOVLW  06
0342:  MOVWF  2E
0343:  MOVLW  20
0344:  MOVWF  2F
0345:  CALL   19A
0346:  DECFSZ 2E,F
0347:  GOTO   343
....................    verifica(); 
0348:  GOTO   21F
....................    while(1) 
....................    { 
....................    if(bloqueio)func_normal();  //se bloqueio for==1  
0349:  BTFSC  2B.0
034A:  GOTO   29A
....................    if(!bloqueio)func_bloqueado();//se bloqueio for==0 
034B:  BTFSS  2B.0
034C:  GOTO   2DA
....................    } 
034D:  GOTO   349
.................... } 
034E:  SLEEP

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
